Le comportement du mot clé this est particulier en JS.

*** Contexte global ***

Dans le contexte global d'exécution (donc hors de toute fonction), 'this' fait référence à l'objet global.
Pour un navigateur, il d'agira de l'objet {window}.
Il est notable que cet objet global est accessible que que soit le contexte d'exécution avec 'globalThis'.

*** Contexte d'une fonction ***

Si 'this' est utilisé dans une fonction, alors sa valeur variera en fonction de l'endroit où la fonction a été appelé.

Lorsque l'on utilise ce type de code en mode non strict :

function f1(){
  return this;
}

// Dans un navigateur
f1() === window; // true (objet global)

f1() retourne 'window'.

Par contre en mode strict :

function f2(){
  "use strict"; // on utilise le mode strict
  return this;
}

f2() === undefined; // true

f2() retourne "undefined". Pour que f2() retourne window, il aurait fallu écrire window.f2()!

*** Call et Apply ***

Lorsque le mot clé 'this' est utilisé dans le corps d'une fonction, il est possible de lier this à un objet lambda en utilisant les méthodes call() ou apply().

var obj = { a: "Toto" };
function whatsThis(arg) { return this.a }
whatsThis();          // 'Global' car celui-ci dans la fonction n'est pas défini, il est donc défini par défaut sur l'objet global window
whatsThis.call(obj);  // "Toto"
whatsThis.apply(obj); // "Toto"

La différence entre call et apply est que call() accepte une liste d'argument, tandis que apply accepte un unique tableau d'argument.
function ajout(c, d){
  return this.a + this.b + c + d;
}
var o = {a:1, b:3};
ajout.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
ajout.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34

*** La méthode Bind ***

La méthode bind() permet de créer une nouvelle fonction à partir de la fonction originel, qui possède le même corps et la même portée, mais dont 'this' est lié au premier argument passé à bind().

function f(){
  return this.a;
}

var g = f.bind({a:"azerty"});
console.log(g()); // azerty

var h = g.bind({a:"coucou"}); // bind ne fonctionne qu'une seule fois!
console.log(h()); // azerty

*** Fonction fléchées ***
Les fonctions fléchées sont particulières : 'this' dans la fonction fléchée sera toujours égal à la valeur du 'this' du contexte où la fonction fléchée a été définie.
Par exemple s'il s'agit du contexte global :

var objetGlobal = this;
var toto = (() => this);
console.log(toto() === objetGlobal); // true
// Appelé comme la méthode d'un objet
var obj = {toto: toto};
console.log(obj.toto() === objetGlobal); // true

// Ici on utilise call
console.log(toto.call(obj) === objetGlobal); // true
// Là on utilise bind
toto = toto.bind(obj);
console.log(toto() === objetGlobal); // true

Ici on voit bien que même l'utilisation de call(), apply() n'y font rien.


