-------------------------------------
*** Creating a regular expression ***
-------------------------------------

Une expression régulière est un objet. Elle peut être créée de deux manières :

let re1 = new RegExp("abc");
let re2 = /abc/;

Les deux variables représente un a, suivi d'un b, suivi d'un c.
Le constructeur RegExp permet d'écrire la regexp sous la forme d'une chaîne de caractère.

La seconde notation implique de commencer et finir la regexp avec des barre obliques = slashs. Si l'on veut intégrer des slashs à notre regexp, il faut alors l'échapper (avec un backslash). Ceci est vrai également pour les caractères spéciaux : points d'interrogation, signe plus, etc.


---------------------------
*** Testing for matches ***
---------------------------
Il est possible de tester ses regex en utilisant la méthode test() :

console.log(/abc/.test("abcde"));
// → true
console.log(/abc/.test("abxde"));
// → false

--------------------------
*** Sets of characters ***
--------------------------

/[0123456789]/ ou /[0-9]/ permet de vérfier si une chaîne de caractère contient un chiffre.
Un trait d'union entre deux caractère indique une plage de caractère. Attention, la plage est déterminé par leur position dans le tableau Unicode!
Il existe des expressions spéciales pour exprimer certaines plages de caractère communes :

   \d	 => n'importe quelle chiffre
   \w	 => n'importe quelle caractère alphanumérique
   \s  => n'importe quelle espace blanc (espace, tab, nouvelle ligne, etc)
   \D	 => n'importe quel caractère qui n'est pas un chiffre
   \W  => n'importe quel caractère qui n'est pas alphanumérique
   \S  => n'importe quel caractère qui n'est pas un espace blanc
   .	 => n'importe quel caractère sauf une nouvelle ligne

Pour combiner plusieurs possibilités, il faut utiliser un tableau. Par exemple [\d.] accepte n'importe quel chiffre ou un point.
Lorsque l'on veut exclure des caractères, il faut utiliser un accent circonflexe : /[^01]/ => accepte tous sauf 0 ou 1.

------------------------------------
*** Repeating parts of a pattern ***
------------------------------------
Lorsque l'on souhaite répéter un shéma, par exemple rechercher une suite de chiffre, on peut utiliser le caractère spécial '+'.
Par exemple /\d+/ fonctionne pour '123'.
La notation /\d*/ est similaire, mais accepte aussi le cas ou la suite est vide => ''.
Pour rechercher une suite de séquence de caractère, il faut utiliser des parenthèses => /(cou+)/ fonctionnera avec "coucoucoucou".

Un point d'interrogation permet de rendre un caractère optionnel. Par exemple pour /voisin?s/, le s final est optionnel.

Lorsque l'on souhaite qu'un shéma soit répété un nombre précis de fois, il faut utiliser des accolades.
   - \d{4} indique que l'on souhaite avoir un nombre à 4 chiffre
   - \d{2,5} indique que l'on souhaite avoir un nombre entre 2 et 5 chiffres.

--------------------------
*** Matches and Groups ***
--------------------------

La méthode test() des regex renvoie simplement si la recherche aboutit. D'autres fonctions existent, comme par exemple exec().
Cette méthode retourne la chaîne de caractère trouvée qui colle à la regex, ainsi que sa position dans la chaîne initiale.

let match = /\d+/.exec("one two 100");
console.log(match);
// → ["100"]
console.log(match.index);
// → 8

Il est possible de rechercher des sous-groupes, avec l'utilisation de parenthèses.
Par exemple la regex /bad(ly)?/ va rechercher la chaine bad, optionnellement badly.
La méthode exec) retournera alors la chaîne trouvée 'badly', et le groupe 'ly'.
Dans le cas où plusieurs groupe 'ly' serait présent, seul le dernier serait retourné :

/bad(ly)?/.exec("badly") => ['badly', 'ly', index: 0, input: 'badly', groups: undefined]

Les groupes peuvent être utiles pour extraire une partie d'une chaîne de caractère, et l'utiliser à d'autre fins!

----------------------
*** The date class ***
----------------------
JS possède une classe pour représenter un point dans le temps - Date.

console.log(new Date());
// → Mon Nov 13 2017 16:19:11 GMT+0100 (CET)

Il est possible de créér un objet Date à une date spécifique.
Attention, les mois commence à l'index 0, tandis que les jours débutent à l'index 1.

console.log(new Date(2009, 11, 9, 12, 59, 59, 999));
// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)

En plaçant judicieusement ses groupes au sein de la regex, il est possible d'en extraire un objet Date :

function getDate(string) {
  let [_, month, day, year] =
    /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
  return new Date(year, month - 1, day);
}
console.log(getDate("1-30-2003"));
// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)

----------------------------------
*** Word and String Boundaries ***
----------------------------------
Il est possible d'utiliser les marqueurs :
   - ^ pour marquer le début de la cible;
   - $ pour marquer la fin de la cible.

Ainsi, l'expression régulière /^\d+$/ implique une suite de chiffre entre le début et la fin de la cible. Si la cible est composé d'un seul chiffre, ou bien possède un caractère autre qu'un chiffre, la regex ne fonctionnera pas.

Un autre marqueur utile est \b. Il permet de marquer la transition entre un caractère alphanumérique et un caractère non alphanumérique. Il est surtout utilisé pour marquer le début ou la fin d'un mot.

console.log(/cat/.test("concatenate"));
// → true
console.log(/\bcat\b/.test("concatenate"));
// → false

La seconde expression régulière ne fonctionne pas à cause du second \b.

-----------------------
*** Choice patterns ***
-----------------------

Lorsque l'on souhaite que plusieurs choix soit possible sur notr eregex, il faut utiliser des pipes.
Par exemple, la regex /\b\d+ (pig|cow|chicken)s?\b/ recherche un nombre, suivi d'un espace, suivi d'un des trois mots pig, cow ou chicken, éventuellement au pluriel.

---------------------------------
*** The Mechanics of Matching ***
---------------------------------

Lorsque l'on utilise les méthodes exec() ou test(), le moteur de regex essaie de trouver une correspondance dans notre cible en débutant par le premier caractère, puis le second, etc.

De plus, pour une regex = /^.*X/ (=> une cible qui début par n'importe quelle caractère sauf new line, répété 0 ou plusieurs fois, et qui se termine par un x).

Si on lui passe la cible "aaXaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", le moteur de regex va commencer par appliquer .* sur toute la cible, avant de se rendre compte qu'elle a besoin d'un X final. Elle va alors revenir en arrière d'un cran, et ainsi de suite, jusqu'à tomber sur le X en troisième position. Ce mécanisme de retour en arrière peut entraîner une consommation importante des ressources lorsque la regex n'est pas assez précise.

--------------------------
*** The Replace Method ***
--------------------------
