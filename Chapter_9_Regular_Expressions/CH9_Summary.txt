-------------------------------------
*** Creating a regular expression ***
-------------------------------------

Une expression régulière est un objet. Elle peut être créée de deux manières :

let re1 = new RegExp("abc");
let re2 = /abc/;

Les deux variables représente un a, suivi d'un b, suivi d'un c.
Le constructeur RegExp permet d'écrire la regexp sous la forme d'une chaîne de caractère.

La seconde notation implique de commencer et finir la regexp avec des barre obliques = slashs. Si l'on veut intégrer des slashs à notre regexp, il faut alors l'échapper (avec un backslash). Ceci est vrai également pour les caractères spéciaux : points d'interrogation, signe plus, etc.


---------------------------
*** Testing for matches ***
---------------------------
Il est possible de tester ses regex en utilisant la méthode test() :

console.log(/abc/.test("abcde"));
// → true
console.log(/abc/.test("abxde"));
// → false

--------------------------
*** Sets of characters ***
--------------------------

/[0123456789]/ ou /[0-9]/ permet de vérfier si une chaîne de caractère contient un chiffre.
Un trait d'union entre deux caractère indique une plage de caractère. Attention, la plage est déterminé par leur position dans le tableau Unicode!
Il existe des expressions spéciales pour exprimer certaines plages de caractère communes :

   \d	 => n'importe quelle chiffre
   \w	 => n'importe quelle caractère alphanumérique
   \s  => n'importe quelle espace blanc (espace, tab, nouvelle ligne, etc)
   \D	 => n'importe quel caractère qui n'est pas un chiffre
   \W  => n'importe quel caractère qui n'est pas alphanumérique
   \S  => n'importe quel caractère qui n'est pas un espace blanc
   .	 => n'importe quel caractère sauf une nouvelle ligne

Pour combiner plusieurs possibilités, il faut utiliser un tableau. Par exemple [\d.] accepte n'importe quel chiffre ou un point.
Lorsque l'on veut exclure des caractères, il faut utiliser un accent circonflexe : /[^01]/ => accepte tous sauf 0 ou 1.

------------------------------------
*** Repeating parts of a pattern ***
------------------------------------
Lorsque l'on souhaite répéter un shéma, par exemple rechercher une suite de chiffre, on peut utiliser le caractère spécial '+'.
Par exemple /\d+/ fonctionne pour '123'.
La notation /\d*/ est similaire, mais accepte aussi le cas ou la suite est vide => ''.
Pour rechercher une suite de séquence de caractère, il faut utiliser des parenthèses => /(cou+)/ fonctionnera avec "coucoucoucou".

Un point d'interrogation permet de rendre un caractère optionnel. Par exemple pour /voisin?s/, le s final est optionnel.

Lorsque l'on souhaite qu'un shéma soit répété un nombre précis de fois, il faut utiliser des accolades.
   - \d{4} indique que l'on souhaite avoir un nombre à 4 chiffre
   - \d{2,5} indique que l'on souhaite avoir un nombre entre 2 et 5 chiffres.

--------------------------
*** Matches and Groups ***
--------------------------

La méthode test() des regex renvoie simplement si la recherche aboutit. D'autres fonctions existent, comme par exemple exec().
Cette méthode retourne la chaîne de caractère trouvée qui colle à la regex, ainsi que sa position dans la chaîne initiale.

let match = /\d+/.exec("one two 100");
console.log(match);
// → ["100"]
console.log(match.index);
// → 8

Il est possible de rechercher des sous-groupes, avec l'utilisation de parenthèses.
Par exemple la regex /bad(ly)?/ va rechercher la chaine bad, optionnellement badly.
La méthode exec) retournera alors la chaîne trouvée 'badly', et le groupe 'ly'.
Dans le cas où plusieurs groupe 'ly' serait présent, seul le dernier serait retourné :

/bad(ly)?/.exec("badly") => ['badly', 'ly', index: 0, input: 'badly', groups: undefined]

Les groupes peuvent être utiles pour extraire une partie d'une chaîne de caractère, et l'utiliser à d'autre fins!

----------------------
*** The date class ***
----------------------
JS possède une classe pour représenter un point dans le temps - Date.

console.log(new Date());
// → Mon Nov 13 2017 16:19:11 GMT+0100 (CET)

Il est possible de créér un objet Date à une date spécifique.
Attention, les mois commence à l'index 0, tandis que les jours débutent à l'index 1.

console.log(new Date(2009, 11, 9, 12, 59, 59, 999));
// → Wed Dec 09 2009 12:59:59 GMT+0100 (CET)

En plaçant judicieusement ses groupes au sein de la regex, il est possible d'en extraire un objet Date :

function getDate(string) {
  let [_, month, day, year] =
    /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
  return new Date(year, month - 1, day);
}
console.log(getDate("1-30-2003"));
// → Thu Jan 30 2003 00:00:00 GMT+0100 (CET)

----------------------------------
*** Word and String Boundaries ***
----------------------------------
Il est possible d'utiliser les marqueurs :
   - ^ pour marquer le début de la cible;
   - $ pour marquer la fin de la cible.

Ainsi, l'expression régulière /^\d+$/ implique une suite de chiffre entre le début et la fin de la cible. Si la cible est composé d'un seul chiffre, ou bien possède un caractère autre qu'un chiffre, la regex ne fonctionnera pas.

Un autre marqueur utile est \b. Il permet de marquer la transition entre un caractère alphanumérique et un caractère non alphanumérique. Il est surtout utilisé pour marquer le début ou la fin d'un mot.

console.log(/cat/.test("concatenate"));
// → true
console.log(/\bcat\b/.test("concatenate"));
// → false

La seconde expression régulière ne fonctionne pas à cause du second \b.

-----------------------
*** Choice patterns ***
-----------------------

Lorsque l'on souhaite que plusieurs choix soit possible sur notr eregex, il faut utiliser des pipes.
Par exemple, la regex /\b\d+ (pig|cow|chicken)s?\b/ recherche un nombre, suivi d'un espace, suivi d'un des trois mots pig, cow ou chicken, éventuellement au pluriel.

---------------------------------
*** The Mechanics of Matching ***
---------------------------------

Lorsque l'on utilise les méthodes exec() ou test(), le moteur de regex essaie de trouver une correspondance dans notre cible en débutant par le premier caractère, puis le second, etc.

De plus, pour une regex = /^.*X/ (=> une cible qui début par n'importe quelle caractère sauf new line, répété 0 ou plusieurs fois, et qui se termine par un x).

Si on lui passe la cible "aaXaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", le moteur de regex va commencer par appliquer .* sur toute la cible, avant de se rendre compte qu'elle a besoin d'un X final. Elle va alors revenir en arrière d'un cran, et ainsi de suite, jusqu'à tomber sur le X en troisième position. Ce mécanisme de retour en arrière peut entraîner une consommation importante des ressources lorsque la regex n'est pas assez précise.

--------------------------
*** The Replace Method ***
--------------------------
La méthode string.replace() permet de remplacer une partie d'une chaîne de caractère avec une autre.
Elle peut être utilisée avec les regex. Normalement, seul le premier match sera remplacé ; à moins d'ajouter l'option g (pour global) à la regex :

console.log("Borobudur".replace(/[ou]/, "a"));
// → Barobudur
console.log("Borobudur".replace(/[ou]/g, "a"));
// → Barabadar

La méthode replace est puissante car elle permet de travailler avec les groupes des regex.

console.log(
  "Liskov, Barbara\nMcCarthy, John\nWadler, Philip"
    .replace(/(\w+), (\w+)/g, "$2 $1"));
// → Barbara Liskov
//   John McCarthy
//   Philip Wadler

Ici, la regex sélectionne toutes les occurrences nom, prénom, les lie au groupe $1 et $2, puis les intervertit.
Il est possible de coupler jusqu'à 9 groupes ($1 => $9). Le match global est accessible avec '$&'.

Il est possible de passer une fonction en second argument :

let s = "the cia and fbi";
console.log(s.replace(/\b(fbi|cia)\b/g,
            str => str.toUpperCase()));
// → the CIA and FBI

Les arguments passés à la fonction sont le match global, suivi des groupes, dans l'ordre (func(globalMatch, group1, group2, etc))

-------------
*** Greed ***
-------------

On peut utiliser la méthode replace pour supprimer les commentaires d'un code JS. Voici une première version de regex pour effectuer ce traitement, mais qui possède une imprécision :

function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*\*\//g, "");
}

Cette regex recherche les patterns // + suite de caractères sauf newline avec 0..n occurrences OU /* + suite de tous les caractères (newline inclus) avec 0..n occurences + */.
Voici les résultats obtenus avec différentes chaîne de caractère :

console.log(stripComments("1 + /* 2 */3"));
// → 1 + 3
console.log(stripComments("x = 10;// ten!"));
// → x = 10;
console.log(stripComments("1 /* a */+/* b */ 1"));
// → 1  1

On peut remarquer que le troisième test à échoué, le + manque. Ceci est dû au fait que les opérateurs +, *, ? et {} sont dits "gourmands" (greedy). Le pattern [^]* est appliqué sur notre cible tant qu'il colle à notre cible. Il va donc fonctionner jusq'à atteindre le bout de notre cible. Puis la regex va effectuer un retour en arrière progressif, jusqu'à trouver la suite */. C'est pour cela que le + est zappé dans l'exemple 3.

Il est possible d'inverser leur comportement en leur ajoutant l'opérateurs ? => +?, *?, ?? et {}?.
Dans ce cas, le pattern sera appliqué au minimum, et essaiera à chaque cran de faire coller le pattern qui le suit - dans ce cas */.

function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*?\*\//g, "");
}
console.log(stripComments("1 /* a */+/* b */ 1"));
// → 1 + 1

Maintenant, cela fonctionne. La plupart du temps, les erreurs liés aux regex sont du au caractère gourmands des opérateurs de répétition.
L'auteur conseille d'utiliser la variante non gourmande de ces opérateurs dans les applications réélles.

-------------------------------------------
*** Dynamically creating regexp objects ***
-------------------------------------------
Il est possible d'intégrer des variables à notre regex en utilisant le constructeur new Regexp() :

let name = "harry";
let regexp = new RegExp("\\b(" + name + ")\\b", "gi");

Attention à doubler les backslashs pour les expressions spéciales (\b => \\b) car il s'agit d'une chaine de caractère classique.
Les ajouts g (global) et i (insensible à la casse) sont précisés en second argument.

-------------------------
*** The search method ***
-------------------------

Il n'est pas possible d'utiliser la méthode indexOf avec une regex. Par contre on peut utiliser la méthode search() :

console.log("  word".search(/\S/));
// → 2
console.log("    ".search(/\S/));
// → -1

------------------------------
*** The lastIndex property ***
------------------------------
Il est possible de spécifier à la méthode exec() à partir de quel index la recherche doit débuter.
C'est une technique détournée dans le sens où il faut modifier la propriété lastIndex de la regex, et la regex doit être global ou sticky :

let pattern = /y/g;
pattern.lastIndex = 3;
let match = pattern.exec("xyzzy");
console.log(match.index);
// → 4
console.log(pattern.lastIndex);
// → 5

A utiliser avec précaution.

----------------------------
*** Looping over matches ***
----------------------------
Lorsque l'on execute plusieurs fois la méthode exec() sur la même regex, nous déplaçons au fur et à mesure sa prop lastIndex.

let input = "A string with 3 numbers in it... 42 and 88.";
let number = /\b\d+\b/g;
number.exec(input); // ['3', index: 14, input:'A string with 3 numbers in it... 42 and 88.', groups: undefined]
number.lastIndex; // 15
number.exec(input); ['42', index: 33, input...
number.lastIndex; // 35
number.exec(input); ['88', index: 40, input...
number.lastIndex; // 42

En effectuant une boucle sur exec(), on peut récupérer l'ensemble de nos valeurs :

let input = "A string with 3 numbers in it... 42 and 88.";
let number = /\b\d+\b/g;
let match;
while (match = number.exec(input)) {
  console.log("Found", match[0], "at", match.index);
}
// → Found 3 at 14
//   Found 42 at 33
//   Found 88 at 40

---------------------------
*** Parsing an Ini file ***
---------------------------
L'auteur fournit un algo pour parser des fichiers ini :

function parseINI(string) {
  // Start with an object to hold the top-level fields
  let result = {};
  let section = result;
  string.split(/\r?\n/).forEach(line => {
    let match;
    if (match = line.match(/^(\w+)=(.*)$/)) {
      section[match[1]] = match[2];
    } else if (match = line.match(/^\[(.*)\]$/)) {
      section = result[match[1]] = {};
    } else if (!/^\s*(;.*)?$/.test(line)) {
      throw new Error("Line '" + line + "' is not valid.");
    }
  });
  return result;
}

console.log(parseINI(`
name=Vasilis
[address]
city=Tessaloniki`));
// → {name: "Vasilis", address: {city: "Tessaloniki"}}

------------------------------
*** Internation characters ***
------------------------------
Il faut faire attention avec les caractères internationaux, les regexs JS fonctionnent curieusement. Par exemple, les caractères é or β ne match pas avec \w mais avec \W!
Des soucis existent aussi avec les caractère spéciaux qui occupent deux unités de code :

console.log(/🍎{3}/.test("🍎🍎🍎"));
// → false
console.log(/<.>/.test("<🌹>"));
// → false
console.log(/<.>/u.test("<🌹>"));
// → true

LE problème vient du fait que la pomme est traité comme deux unités de code. La répétition {3} ne s'applique que sur la moitié droite du code de la pomme - ce qui pose problème.

L'option 'u' permet de traiter ces caractères spéciaux correctement.
