-------------------------------------
*** Creating a regular expression ***
-------------------------------------

Une expression rÃ©guliÃ¨re est un objet. Elle peut Ãªtre crÃ©Ã©e de deux maniÃ¨res :

let re1 = new RegExp("abc");
let re2 = /abc/;

Les deux variables reprÃ©sente un a, suivi d'un b, suivi d'un c.
Le constructeur RegExp permet d'Ã©crire la regexp sous la forme d'une chaÃ®ne de caractÃ¨re.

La seconde notation implique de commencer et finir la regexp avec des barre obliques = slashs. Si l'on veut intÃ©grer des slashs Ã  notre regexp, il faut alors l'Ã©chapper (avec un backslash). Ceci est vrai Ã©galement pour les caractÃ¨res spÃ©ciaux : points d'interrogation, signe plus, etc.


---------------------------
*** Testing for matches ***
---------------------------
Il est possible de tester ses regex en utilisant la mÃ©thode test() :

console.log(/abc/.test("abcde"));
// â†’ true
console.log(/abc/.test("abxde"));
// â†’ false

--------------------------
*** Sets of characters ***
--------------------------

/[0123456789]/ ou /[0-9]/ permet de vÃ©rfier si une chaÃ®ne de caractÃ¨re contient un chiffre.
Un trait d'union entre deux caractÃ¨re indique une plage de caractÃ¨re. Attention, la plage est dÃ©terminÃ© par leur position dans le tableau Unicode!
Il existe des expressions spÃ©ciales pour exprimer certaines plages de caractÃ¨re communes :

   \d	 => n'importe quelle chiffre
   \w	 => n'importe quelle caractÃ¨re alphanumÃ©rique
   \s  => n'importe quelle espace blanc (espace, tab, nouvelle ligne, etc)
   \D	 => n'importe quel caractÃ¨re qui n'est pas un chiffre
   \W  => n'importe quel caractÃ¨re qui n'est pas alphanumÃ©rique
   \S  => n'importe quel caractÃ¨re qui n'est pas un espace blanc
   .	 => n'importe quel caractÃ¨re sauf une nouvelle ligne

Pour combiner plusieurs possibilitÃ©s, il faut utiliser un tableau. Par exemple [\d.] accepte n'importe quel chiffre ou un point.
Lorsque l'on veut exclure des caractÃ¨res, il faut utiliser un accent circonflexe : /[^01]/ => accepte tous sauf 0 ou 1.

------------------------------------
*** Repeating parts of a pattern ***
------------------------------------
Lorsque l'on souhaite rÃ©pÃ©ter un shÃ©ma, par exemple rechercher une suite de chiffre, on peut utiliser le caractÃ¨re spÃ©cial '+'.
Par exemple /\d+/ fonctionne pour '123'.
La notation /\d*/ est similaire, mais accepte aussi le cas ou la suite est vide => ''.
Pour rechercher une suite de sÃ©quence de caractÃ¨re, il faut utiliser des parenthÃ¨ses => /(cou+)/ fonctionnera avec "coucoucoucou".

Un point d'interrogation permet de rendre un caractÃ¨re optionnel. Par exemple pour /voisin?s/, le s final est optionnel.

Lorsque l'on souhaite qu'un shÃ©ma soit rÃ©pÃ©tÃ© un nombre prÃ©cis de fois, il faut utiliser des accolades.
   - \d{4} indique que l'on souhaite avoir un nombre Ã  4 chiffre
   - \d{2,5} indique que l'on souhaite avoir un nombre entre 2 et 5 chiffres.

--------------------------
*** Matches and Groups ***
--------------------------

La mÃ©thode test() des regex renvoie simplement si la recherche aboutit. D'autres fonctions existent, comme par exemple exec().
Cette mÃ©thode retourne la chaÃ®ne de caractÃ¨re trouvÃ©e qui colle Ã  la regex, ainsi que sa position dans la chaÃ®ne initiale.

let match = /\d+/.exec("one two 100");
console.log(match);
// â†’ ["100"]
console.log(match.index);
// â†’ 8

Il est possible de rechercher des sous-groupes, avec l'utilisation de parenthÃ¨ses.
Par exemple la regex /bad(ly)?/ va rechercher la chaine bad, optionnellement badly.
La mÃ©thode exec) retournera alors la chaÃ®ne trouvÃ©e 'badly', et le groupe 'ly'.
Dans le cas oÃ¹ plusieurs groupe 'ly' serait prÃ©sent, seul le dernier serait retournÃ© :

/bad(ly)?/.exec("badly") => ['badly', 'ly', index: 0, input: 'badly', groups: undefined]

Les groupes peuvent Ãªtre utiles pour extraire une partie d'une chaÃ®ne de caractÃ¨re, et l'utiliser Ã  d'autre fins!

----------------------
*** The date class ***
----------------------
JS possÃ¨de une classe pour reprÃ©senter un point dans le temps - Date.

console.log(new Date());
// â†’ Mon Nov 13 2017 16:19:11 GMT+0100 (CET)

Il est possible de crÃ©Ã©r un objet Date Ã  une date spÃ©cifique.
Attention, les mois commence Ã  l'index 0, tandis que les jours dÃ©butent Ã  l'index 1.

console.log(new Date(2009, 11, 9, 12, 59, 59, 999));
// â†’ Wed Dec 09 2009 12:59:59 GMT+0100 (CET)

En plaÃ§ant judicieusement ses groupes au sein de la regex, il est possible d'en extraire un objet Date :

function getDate(string) {
  let [_, month, day, year] =
    /(\d{1,2})-(\d{1,2})-(\d{4})/.exec(string);
  return new Date(year, month - 1, day);
}
console.log(getDate("1-30-2003"));
// â†’ Thu Jan 30 2003 00:00:00 GMT+0100 (CET)

----------------------------------
*** Word and String Boundaries ***
----------------------------------
Il est possible d'utiliser les marqueurs :
   - ^ pour marquer le dÃ©but de la cible;
   - $ pour marquer la fin de la cible.

Ainsi, l'expression rÃ©guliÃ¨re /^\d+$/ implique une suite de chiffre entre le dÃ©but et la fin de la cible. Si la cible est composÃ© d'un seul chiffre, ou bien possÃ¨de un caractÃ¨re autre qu'un chiffre, la regex ne fonctionnera pas.

Un autre marqueur utile est \b. Il permet de marquer la transition entre un caractÃ¨re alphanumÃ©rique et un caractÃ¨re non alphanumÃ©rique. Il est surtout utilisÃ© pour marquer le dÃ©but ou la fin d'un mot.

console.log(/cat/.test("concatenate"));
// â†’ true
console.log(/\bcat\b/.test("concatenate"));
// â†’ false

La seconde expression rÃ©guliÃ¨re ne fonctionne pas Ã  cause du second \b.

-----------------------
*** Choice patterns ***
-----------------------

Lorsque l'on souhaite que plusieurs choix soit possible sur notr eregex, il faut utiliser des pipes.
Par exemple, la regex /\b\d+ (pig|cow|chicken)s?\b/ recherche un nombre, suivi d'un espace, suivi d'un des trois mots pig, cow ou chicken, Ã©ventuellement au pluriel.

---------------------------------
*** The Mechanics of Matching ***
---------------------------------

Lorsque l'on utilise les mÃ©thodes exec() ou test(), le moteur de regex essaie de trouver une correspondance dans notre cible en dÃ©butant par le premier caractÃ¨re, puis le second, etc.

De plus, pour une regex = /^.*X/ (=> une cible qui dÃ©but par n'importe quelle caractÃ¨re sauf new line, rÃ©pÃ©tÃ© 0 ou plusieurs fois, et qui se termine par un x).

Si on lui passe la cible "aaXaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", le moteur de regex va commencer par appliquer .* sur toute la cible, avant de se rendre compte qu'elle a besoin d'un X final. Elle va alors revenir en arriÃ¨re d'un cran, et ainsi de suite, jusqu'Ã  tomber sur le X en troisiÃ¨me position. Ce mÃ©canisme de retour en arriÃ¨re peut entraÃ®ner une consommation importante des ressources lorsque la regex n'est pas assez prÃ©cise.

--------------------------
*** The Replace Method ***
--------------------------
La mÃ©thode string.replace() permet de remplacer une partie d'une chaÃ®ne de caractÃ¨re avec une autre.
Elle peut Ãªtre utilisÃ©e avec les regex. Normalement, seul le premier match sera remplacÃ© ; Ã  moins d'ajouter l'option g (pour global) Ã  la regex :

console.log("Borobudur".replace(/[ou]/, "a"));
// â†’ Barobudur
console.log("Borobudur".replace(/[ou]/g, "a"));
// â†’ Barabadar

La mÃ©thode replace est puissante car elle permet de travailler avec les groupes des regex.

console.log(
  "Liskov, Barbara\nMcCarthy, John\nWadler, Philip"
    .replace(/(\w+), (\w+)/g, "$2 $1"));
// â†’ Barbara Liskov
//   John McCarthy
//   Philip Wadler

Ici, la regex sÃ©lectionne toutes les occurrences nom, prÃ©nom, les lie au groupe $1 et $2, puis les intervertit.
Il est possible de coupler jusqu'Ã  9 groupes ($1 => $9). Le match global est accessible avec '$&'.

Il est possible de passer une fonction en second argument :

let s = "the cia and fbi";
console.log(s.replace(/\b(fbi|cia)\b/g,
            str => str.toUpperCase()));
// â†’ the CIA and FBI

Les arguments passÃ©s Ã  la fonction sont le match global, suivi des groupes, dans l'ordre (func(globalMatch, group1, group2, etc))

-------------
*** Greed ***
-------------

On peut utiliser la mÃ©thode replace pour supprimer les commentaires d'un code JS. Voici une premiÃ¨re version de regex pour effectuer ce traitement, mais qui possÃ¨de une imprÃ©cision :

function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*\*\//g, "");
}

Cette regex recherche les patterns // + suite de caractÃ¨res sauf newline avec 0..n occurrences OU /* + suite de tous les caractÃ¨res (newline inclus) avec 0..n occurences + */.
Voici les rÃ©sultats obtenus avec diffÃ©rentes chaÃ®ne de caractÃ¨re :

console.log(stripComments("1 + /* 2 */3"));
// â†’ 1 + 3
console.log(stripComments("x = 10;// ten!"));
// â†’ x = 10;
console.log(stripComments("1 /* a */+/* b */ 1"));
// â†’ 1  1

On peut remarquer que le troisiÃ¨me test Ã  Ã©chouÃ©, le + manque. Ceci est dÃ» au fait que les opÃ©rateurs +, *, ? et {} sont dits "gourmands" (greedy). Le pattern [^]* est appliquÃ© sur notre cible tant qu'il colle Ã  notre cible. Il va donc fonctionner jusq'Ã  atteindre le bout de notre cible. Puis la regex va effectuer un retour en arriÃ¨re progressif, jusqu'Ã  trouver la suite */. C'est pour cela que le + est zappÃ© dans l'exemple 3.

Il est possible d'inverser leur comportement en leur ajoutant l'opÃ©rateurs ? => +?, *?, ?? et {}?.
Dans ce cas, le pattern sera appliquÃ© au minimum, et essaiera Ã  chaque cran de faire coller le pattern qui le suit - dans ce cas */.

function stripComments(code) {
  return code.replace(/\/\/.*|\/\*[^]*?\*\//g, "");
}
console.log(stripComments("1 /* a */+/* b */ 1"));
// â†’ 1 + 1

Maintenant, cela fonctionne. La plupart du temps, les erreurs liÃ©s aux regex sont du au caractÃ¨re gourmands des opÃ©rateurs de rÃ©pÃ©tition.
L'auteur conseille d'utiliser la variante non gourmande de ces opÃ©rateurs dans les applications rÃ©Ã©lles.

-------------------------------------------
*** Dynamically creating regexp objects ***
-------------------------------------------
Il est possible d'intÃ©grer des variables Ã  notre regex en utilisant le constructeur new Regexp() :

let name = "harry";
let regexp = new RegExp("\\b(" + name + ")\\b", "gi");

Attention Ã  doubler les backslashs pour les expressions spÃ©ciales (\b => \\b) car il s'agit d'une chaine de caractÃ¨re classique.
Les ajouts g (global) et i (insensible Ã  la casse) sont prÃ©cisÃ©s en second argument.

-------------------------
*** The search method ***
-------------------------

Il n'est pas possible d'utiliser la mÃ©thode indexOf avec une regex. Par contre on peut utiliser la mÃ©thode search() :

console.log("  word".search(/\S/));
// â†’ 2
console.log("    ".search(/\S/));
// â†’ -1

------------------------------
*** The lastIndex property ***
------------------------------
Il est possible de spÃ©cifier Ã  la mÃ©thode exec() Ã  partir de quel index la recherche doit dÃ©buter.
C'est une technique dÃ©tournÃ©e dans le sens oÃ¹ il faut modifier la propriÃ©tÃ© lastIndex de la regex, et la regex doit Ãªtre global ou sticky :

let pattern = /y/g;
pattern.lastIndex = 3;
let match = pattern.exec("xyzzy");
console.log(match.index);
// â†’ 4
console.log(pattern.lastIndex);
// â†’ 5

A utiliser avec prÃ©caution.

----------------------------
*** Looping over matches ***
----------------------------
Lorsque l'on execute plusieurs fois la mÃ©thode exec() sur la mÃªme regex, nous dÃ©plaÃ§ons au fur et Ã  mesure sa prop lastIndex.

let input = "A string with 3 numbers in it... 42 and 88.";
let number = /\b\d+\b/g;
number.exec(input); // ['3', index: 14, input:'A string with 3 numbers in it... 42 and 88.', groups: undefined]
number.lastIndex; // 15
number.exec(input); ['42', index: 33, input...
number.lastIndex; // 35
number.exec(input); ['88', index: 40, input...
number.lastIndex; // 42

En effectuant une boucle sur exec(), on peut rÃ©cupÃ©rer l'ensemble de nos valeurs :

let input = "A string with 3 numbers in it... 42 and 88.";
let number = /\b\d+\b/g;
let match;
while (match = number.exec(input)) {
  console.log("Found", match[0], "at", match.index);
}
// â†’ Found 3 at 14
//   Found 42 at 33
//   Found 88 at 40

---------------------------
*** Parsing an Ini file ***
---------------------------
L'auteur fournit un algo pour parser des fichiers ini :

function parseINI(string) {
  // Start with an object to hold the top-level fields
  let result = {};
  let section = result;
  string.split(/\r?\n/).forEach(line => {
    let match;
    if (match = line.match(/^(\w+)=(.*)$/)) {
      section[match[1]] = match[2];
    } else if (match = line.match(/^\[(.*)\]$/)) {
      section = result[match[1]] = {};
    } else if (!/^\s*(;.*)?$/.test(line)) {
      throw new Error("Line '" + line + "' is not valid.");
    }
  });
  return result;
}

console.log(parseINI(`
name=Vasilis
[address]
city=Tessaloniki`));
// â†’ {name: "Vasilis", address: {city: "Tessaloniki"}}

------------------------------
*** Internation characters ***
------------------------------
Il faut faire attention avec les caractÃ¨res internationaux, les regexs JS fonctionnent curieusement. Par exemple, les caractÃ¨res Ã© or Î² ne match pas avec \w mais avec \W!
Des soucis existent aussi avec les caractÃ¨re spÃ©ciaux qui occupent deux unitÃ©s de code :

console.log(/ğŸ{3}/.test("ğŸğŸğŸ"));
// â†’ false
console.log(/<.>/.test("<ğŸŒ¹>"));
// â†’ false
console.log(/<.>/u.test("<ğŸŒ¹>"));
// â†’ true

LE problÃ¨me vient du fait que la pomme est traitÃ© comme deux unitÃ©s de code. La rÃ©pÃ©tition {3} ne s'applique que sur la moitiÃ© droite du code de la pomme - ce qui pose problÃ¨me.

L'option 'u' permet de traiter ces caractÃ¨res spÃ©ciaux correctement.
